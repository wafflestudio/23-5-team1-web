import {
	createContext,
	type ReactNode,
	useCallback,
	useContext,
	useEffect,
	useState,
} from "react";
import * as userService from "@api/user";
import type { Category, Event, Memo } from "@types";
import { useAuth } from "./AuthProvider";

interface UserDataContextType {
	bookmarkedEvents: Event[];
	interestCategories: Category[];
	excludedKeywords: { id: number; keyword: string }[];
	eventMemos: Memo[];
	refreshUserData: () => void;
	addExcludedKeyword: (keyword: string) => Promise<void>;
	deleteExcludedKeyword: (id: number) => Promise<void>;
	toggleBookmark: (event: Event) => Promise<void>;
	getMemoByTag: (tagId: number) => Promise<Memo[]>;
	addMemo: (
		eventId: number,
		content: string,
		tagNames: string[],
	) => Promise<void>;
	deleteMemo: (id: number) => Promise<void>;
	updateMemo: (id: number, updates: {
		content?: string | undefined;
		tagNames?: string[] | undefined;
	}) => Promise<Memo | null>
}

const UserDataContext = createContext<UserDataContextType | undefined>(
	undefined,
);

export const UserDataProvider = ({ children }: { children: ReactNode }) => {
	const { isAuthenticated } = useAuth();
	const [excludedKeywords, setExcludedKeywords] = useState<
		{ id: number; keyword: string }[]
	>([]);
	const [bookmarkedEvents, setBookmarkedEvents] = useState<Event[]>([]);
	const [interestCategories, setInterestCategories] = useState<Category[]>([]);
	const [eventMemos, setEventMemos] = useState<Memo[]>([]);

	const fetchAll = useCallback(async () => {
		if (!isAuthenticated) return;
		try {
			// Parallel fetch
			const [excludedData, bookmarksData, interestsData, memoData] =
				await Promise.all([
					userService.getExcludedKeywords(),
					userService.getBookmarks(1), // Fetch first page/all
					userService.getInterestCategories(),
					userService.getMemos(),
				]);
			setExcludedKeywords(excludedData);
			setBookmarkedEvents(bookmarksData);
			setInterestCategories(interestsData);
			setEventMemos(memoData);
		} catch (error) {
			console.error("Failed to load user data", error);
		}
	}, [isAuthenticated]);

	useEffect(() => {
		if (isAuthenticated) {
			fetchAll();
		} else {
			setExcludedKeywords([]);
			setBookmarkedEvents([]);
			setInterestCategories([]);
			setEventMemos([]);
		}
	}, [isAuthenticated, fetchAll]);

	// Optimistic UI Update for Bookmarking
	const toggleBookmark = async (event: Event) => {
		const isBookmarked = bookmarkedEvents.some((b) => b.id === event.id);

		// 1. Optimistic Update
		if (isBookmarked) {
			setBookmarkedEvents((prev) => prev.filter((b) => b.id !== event.id));
		} else {
			setBookmarkedEvents((prev) => [...prev, event]);
		}

		// 2. API Call
		try {
			if (isBookmarked) {
				await userService.removeBookmark(event.id);
			} else {
				await userService.addBookmark(event.id);
			}
		} catch (error) {
			// Revert on failure
			fetchAll();
			console.error(error);
			alert("Failed to update bookmark");
		}
	};

	const addExcludedKeyword = async (keyword: string) => {
		try {
			await userService.addExcludedKeywords(keyword);
			const excludedData: { id: number; keyword: string }[] =
				await userService.getExcludedKeywords();
			setExcludedKeywords(excludedData);
		} catch (error) {
			console.error("error in adding excluded keyword", error);
		}
	};

	const deleteExcludedKeyword = async (id: number) => {
		try {
			await userService.deleteExcludedKeywords(id);
			const excludedData: { id: number; keyword: string }[] =
				await userService.getExcludedKeywords();
			setExcludedKeywords(excludedData);
		} catch (error) {
			console.error("error in deleting excluded keyword", error);
		}
	};

	/* --- Memo --- */
	const getMemoByTag = async (tagId: number) => {
		try {
			const resultMemos: Memo[] = await userService.getMemoByTag(tagId);
			return resultMemos;
		} catch (error) {
			console.error("error in getting memos by Tag", error);
			return [];
		}
	};

	const addMemo = async (eventId: number, content: string, tags: string[]) => {
		try {
			await userService.addMemo(eventId, content, tags);
			// refresh on add
			const newMemos = await userService.getMemos();
			setEventMemos(newMemos);
		} catch (error) {
			console.error("error in adding memos", error);
		}
	};

	const deleteMemo = async (id: number) => {
		try {
			await userService.deleteMemo(id);
			const newMemos = await userService.getMemos();
			setEventMemos(newMemos);
		} catch (error) {
			console.error("error in deleting memos", error);
		}
	};

	const updateMemo = async (id: number, updates: { content?: string; tagNames?: string[] }) => {
		try {
			const newMemo: Memo = await userService.editMemo(id, updates);

			setEventMemos((prevMemos) => 
				prevMemos.map((memo) => memo.id === id ? newMemo : memo));
			
			return newMemo;
		} catch (error) {
        console.error("error in updating memo", error);
        return null;
    }
}

	return (
		<UserDataContext.Provider
			value={{
				excludedKeywords,
				bookmarkedEvents,
				interestCategories,
				eventMemos,
				refreshUserData: fetchAll,
				toggleBookmark,
				getMemoByTag,
				addMemo,
				deleteMemo,
				updateMemo,
				addExcludedKeyword,
				deleteExcludedKeyword,
			}}
		>
			{children}
		</UserDataContext.Provider>
	);
};

export const useUserData = () => {
	const context = useContext(UserDataContext);
	if (!context) throw new Error("useUserData error");
	return context;
};
